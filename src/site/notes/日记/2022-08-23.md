---
{"dg-publish":true,"permalink":"/日记/2022-08-23/","dgPassFrontmatter":true}
---

<< [[日记/2022-08-22\|2022-08-22]] | [[日记/2022-08-24\|2022-08-24]] >>
## 🕓今日主题
* [[卡片/哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！\|哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！]] 
	* [[卡片/P218.分布式事务有哪些解决方案\|P218.分布式事务有哪些解决方案]]
		* [[Logseq元问题库/pages/？分布式 事务 解决方案\|？分布式 事务 解决方案]]
			* 基于 数据库支持的 #XA协议 ，和Java提供 的 #JTA API
				* [[Logseq元知识库/pages/XA协议\|XA协议]]
					* 0|是一种通用的解决分布式事务的协议，主要定义了 [[Logseq元知识库/pages/事务管理器\|事务管理器]]（TM）和[[Logseq元知识库/pages/资源管理器\|资源管理器]]（RM）之间的接口。TM负责协调多个RM的提交和回滚，RM是负责管理本地资源和本地事务的。
					* 1|[[Logseq元知识库/pages/2PC\|2PC]]
						* 0|即两阶段提交（先准备再提交)的分布式系统共识协议
						* 1|![图](https://pic1.zhimg.com/v2-e2f7149a81d9ad3aa46589e25503d688_r.jpg)
						  ![t](https://pic4.zhimg.com/v2-d40abfa365ed84e84e264ba13900f64b_r.jpg)
							* 0|提议阶段(也可以说是准备阶段)
							    - 协调者向所有参与者发送提案，并等待它们的响应
							    - 参与者收到提案后，根据自己的情况决定是否同意或拒绝，并回复协调者
							    - 协调者收集所有参与者的响应，判断是否所有参与者都同意了提案
							- 1|提交阶段
							    - 如果所有参与者都同意了提案，协调者向所有参与者发送commit消息，并等待它们的确认；如果有任何一个参与者拒绝或没有响应，协调者就会发出abort消息
							    - 如果收到commit消息，参与者执行提案，并回复协调者； 如果收到abort消息，参与者取消提案，并回复协调者；
							    - 协调者收集所有参与者的确认，完成或取消提案
						*  2|[[Logseq元知识库/pages/2PC\|2PC]]有一个痛点就是如果协调者将要发出消息令众参与者提交的那一瞬间前协调者和一个参与者挂掉了：其一，**剩余的参与者根本不知道自己应当是提交还是放弃**，因为无法从协调者那里得到协调者的命令是提交还是放弃，即使假定剩余参与者可以**通过交流或者选出新的协调者**来确定彼此都是投赞成票，但无法从那个挂掉的参与者获悉其有没有投反对票，因此不能根据投票规则推理出协调者本应发出的命令是什么；其二，[[Logseq元知识库/pages/2PC\|2PC]] 显然是一个阻塞协议，协调者挂掉，所有参与者只能等待 ，参与者异常，协调者同样要等待^4t34us 
												* 以上痛点会延伸以下问题：
													* 不确定性
													* 单点故障
													* 数据不一致：有RM未收到commit
													* 响应时间长
								
					* 2|[[Logseq元知识库/pages/XA协议\|XA协议]] 提出的经典流程属于[[Logseq元知识库/pages/2PC\|2PC]]，其分为以下步骤：
						* [[Logseq元知识库/pages/XA协议.2PC\|XA协议.2PC]]
							* ![Pasted image 20220823195704.png](/img/user/Logseq%E5%85%83%E9%97%AE%E9%A2%98%E5%BA%93/assets/Pasted%20image%2020220823195704.png)
							- 0|TM向所有的RM发送prepare请求，要求它们准备执行事务，并等待它们的响应。
							- 1|RM收到prepare请求后，执行本地事务，并锁定相关资源，然后向TM回复yes或no，表示是否准备好提交。
							- 2|TM收到所有RM的响应后，如果都是yes，就向所有RM发送commit请求，要求它们提交事务，并释放资源。如果有任何一个no，就向所有RM发送rollback请求，要求它们回滚事务，并释放资源。
							- 3|RM收到commit或rollback请求后，执行相应的操作，并向TM回复完成的消息。
							- 4|TM收到所有RM的完成消息后，结束事务。
						- 
					- 3|[[Logseq元知识库/pages/XA协议\|XA协议]] 中的TM角色通常是一个独立的中间件或者基于(分布式协调)框架构建在Java应用中的对象来承担，比如Seata、Narayana等，这样才能进行统一的事务协调。而RM的角色一般由业务应用以及对应的业务数据库承担, 且不可或缺业务数据库层面的支持，否则不可能完成RM的动作，也因此数据库支持[[Logseq元知识库/pages/XA协议\|XA协议]]是必须的，为了适配数据库[[Logseq元知识库/pages/XA协议\|XA协议]] ，Java应用参与RM时可考虑使用兼容[[Logseq元知识库/pages/XA协议\|XA协议]] 的[[Logseq元知识库/pages/JTA\|JTA]] API。以MySQL为例，其只有 [[Logseq元知识库/pages/Innodb\|Innodb]]支持[[Logseq元知识库/pages/XA协议\|XA协议]] ，start XA命令可开启XA RM事务。以[[Logseq元知识库/pages/Spring\|Spring]]为例，其提供了一个JtaTransactionManager类，该类组合了一个XA TM的容器对象或本地代理对象，任何Spring Java应用都可以通过JtaTransactionManager为一个方法开启一个XA事务(但本质上是从XA TM申请了一个有id的分布式事务)，方法内的本地数据操作将按照数据源分解为一个个小的RM 事务发送到对应的数据源，方法内对其他系统调用而产生的数据操作也是如此分解，并且归属于申请到的分布式事务
				- 基于[[Logseq元知识库/pages/XA协议\|XA协议]] 的分布式事务方案优缺点：
					- 缺点：
						- 因为依赖TM协调，所以存在单点故障和网络分区的问题，这样事务会因为一直准备而阻塞，一个不小心甚至会死锁。[[Logseq元知识库/pages/XA协议\|XA协议]] 的优化版流程（3PC）只能在一定程度上解决这些问题
						- 依赖数据库对[[Logseq元知识库/pages/XA协议\|XA协议]] 的支持，限制了其使用场景 
						- MySQL在执行XA事务时会产生undo日志和redo日志，这会增加磁盘空间和IO开销；MySQL在执行XA事务时会锁定相关资源，这会影响并发性能和死锁风险等
					- 优点：
						- 实现较为简便
			* 基于事务补偿机制： #TCC 。这种其实基于业务层面实现
				* [[Logseq元知识库/pages/TCC\|TCC]] 
					* 一种[[Logseq元知识库/pages/分布式事务\|分布式事务]] 方案，含义即**Try-Confirm-Cancel**。
					* 核心思想是通过**补偿机制**，在事务出现异常或失败时，通过**执行相反的操作**(比如提交是+1，那相反就是-1)来取消提交，保证数据的一致性。TCC需要业务层面实现三个接口：Try用于尝试执行业务并预留资源，Confirm用于确认执行业务并使用预留资源，Cancel用于取消执行业务并释放预留资源。](https://juejin.cn/post/7031488136072921101)[1](https://juejin.cn/post/7031488136072921101)[2](https://developer.aliyun.com/article/1049285)

				* TCC相比于传统的2PC（两阶段提交）方案，有以下几个优点：
					- [TCC不会锁定整个资源，而是通过引入业务逻辑形式的资源预留，降低了锁的粒度和冲突。](https://zhuanlan.zhihu.com/p/462669898)[3](https://zhuanlan.zhihu.com/p/462669898)
					- [TCC不需要依赖资源层的支持，而是由业务层自行实现，因此可以适应更多的场景和技术栈。](https://blog.csdn.net/weixin_42653522/article/details/120341977)[4](https://blog.csdn.net/weixin_42653522/article/details/120341977)
					- TCC可以灵活地控制事务的超时时间和重试策略，以应对不同的网络环境和异常情况。[5](https://zhuanlan.zhihu.com/p/148747139)
				* TCC也有一些缺点和挑战：
					- TCC对业务的侵入性较高，需要开发人员编写额外的代码来实现三个接口，并保证它们的空回滚、幂等性和防止资源悬挂。[5](https://zhuanlan.zhihu.com/p/148747139)
					- TCC可能会造成数据的最终一致性，而不是强一致性，因为在Confirm或Cancel阶段可能会出现失败或超时的情况，需要重试或人工干预。[2](https://developer.aliyun.com/article/1049285)
					- [TCC需要记录事务日志来追踪事务状态和结果，这会增加系统的开销和复杂度。](https://zhuanlan.zhihu.com/p/148747139)[5](https://zhuanlan.zhihu.com/p/148747139)
			* 基于[[Logseq元知识库/pages/消息表\|消息表]]
				* 本质上是把[[Logseq元知识库/pages/TCC\|TCC]]方案中的[[Logseq元知识库/pages/接口\|接口]] 调用替换为消息中间件，从而解耦 
				* 基于[[Logseq元知识库/pages/消息表\|消息表]]的分布式事务方案的核心思想是，在业务系统中引入一张本地消息表，用来记录业务操作和消息发送的状态。（T）当业务操作成功后，同时往本地消息表插入一条消息记录，状态为“发送中”。然后再向消息中间件发送一条消息，通知其他系统进行相应的操作。当其他系统成功消费了这条消息后，再反向发送一条确认消息给原始系统，让其更新本地消息表的状态为“已发送”（C）。如果消费操作失败了，发送一条反向操作的消息给原始系统（C）。这里面有些实现细节要注意：
					* 本地事务和消息发送要在同一个数据库事务中完成，保证[[Logseq元知识库/pages/原子性\|原子性]]，否则本地事务操作失败了，消息却也发出去，一致性就完蛋了
					* 消息中间件要支持事务消息或者可靠投递机制，保证消息不丢失
					* 消费者要实现幂等性，避免重复消费造成数据不一致。
					* 依靠消息表记录了消息发送状态，请务必利用这一点来通过定时任务或者重试机制来实现消息的可靠投递，即如果消息发送失败或者丢失，可以根据本地消息表的状态重新发送消息，直到消费成功为止
				* 优点 
					* 引入了[[Logseq元知识库/pages/消息队列\|消息队列]] 
						* 解耦，适合业务复杂的多系统 
						* 异步，不需阻塞，性能ok
					* 消息可靠，不会丢失或重复 
					* 数据最终一致，满足大多数业务场景 
				* 缺点 
					* 引入了[[Logseq元知识库/pages/消息队列\|消息队列]] 
						* 架构变得复杂，需考虑消息投递可靠性、消费冥等性、消息重试等问题 
					* -需要额外创建和维护本地消息表，增加了数据库的负担。
					* 不能保证强一致性，可能存在数据不一致的时间窗口
			* 基于 #MQ 
				* 在 基于[[Logseq元知识库/pages/消息表\|消息表]]方案的基础上去掉消息表，也就是说要完全依靠发送方和 #MQ 的机制保证消息的可靠投递
				* 举个例子，A服务在执行事务的本地操作前，向MQ1发送事务消息，B服务监听MQ2，B服务此时不知道事务在A那里已经完成，A完成后，会再请求MQ1，转移消息到MQ2，此时B服务接受到事务消息，继续后续操作
	* [[卡片/P219.对比两阶段，三阶段有哪些改进\|P219.对比两阶段，三阶段有哪些改进]] 
		* [00:00](http://localhost:5244/d/%E6%88%91%E7%9A%84%E5%BA%A6%E7%9B%98/%E8%A7%86%E9%A2%91/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9-Java%E9%9D%A2%E8%AF%95300%E9%A2%98%EF%BC%88%E6%B6%B5%E7%9B%96Java%E6%89%80%E6%9C%89%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89%E4%B8%80%E7%AB%99%E5%BC%8F%E5%88%B7%E9%A2%98%EF%BC%8C%E7%AB%8B%E5%88%BB%E5%AD%A6%E4%B9%A0%EF%BC%81--%E8%AF%B8%E8%91%9B%E8%80%81%E5%B8%88/P219.%E5%AF%B9%E6%AF%94%E4%B8%A4%E9%98%B6%E6%AE%B5%EF%BC%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%E6%94%B9%E8%BF%9B.mp4#t=0)
			* [[Logseq元知识库/pages/3PC\|3PC]] & [[Logseq元知识库/pages/2PC\|2PC]] 
				* 0| [[Logseq元知识库/pages/3PC\|3PC]] 是对 [[Logseq元知识库/pages/2PC\|2PC]]的改进。分析[[Logseq元知识库/pages/2PC\|2PC]] 的[[日记/2022-08-23#^4t34us\|痛点]]：其一，流程分支的状态迁移出现困境(无法确定接下来是放弃还是提交)，[[Logseq元知识库/pages/3PC\|3PC]] 针对这一点选择了增加流程的解决方式，其思路是：特定的网络分区必然会导致一致意见信息丢失，一致意见信息丢失肯定会出现状态迁移困境，而网络分区这件事不能控制是否发生，所以唯一可行的改进方向就是控制网络分区在意见统一环节发生的概率。[[Logseq元知识库/pages/2PC\|2PC]] 是两步流程，如果能够**增加流程**，那么意见统一环节出现挂掉的概率就会被分走；其二，阻塞问题，根源在于参与者和协调者通行上的相互依赖，所以3PC所选择改进思路有：a）协调者挂掉，参与者可以重新选择协调者。这一改进对于恢复状态迁移、解决单点故障同样有利 b)引入超时后默认操作的机制，避免过长的阻塞,。基于以上思路，[[Logseq元知识库/pages/3PC\|3PC]] 的具体做法是在2PC最前面**增加一个“准备阶段Propose Phase”**，这个“准备阶段”将在不锁定资源的情况下达成意见一致(这个意见只有小概率是错误的，可以作为默认操作)，该阶段一般名为**CanCommit**；2PC原来的两个阶段大致保留，但引入超时后默认操作机制和重新选取协调者，一般名为**PreCommit和DoCommit**
					* ![t](https://pic2.zhimg.com/v2-28c17c86e689007015a4853f0d0c4a89_r.jpg)
				* 1|[[Logseq元知识库/pages/3PC\|3PC]]改善了不确定性、响应时间长，解决了单点故障, 但和[[Logseq元知识库/pages/2PC\|2PC]]一样不能解决[[Logseq元知识库/pages/一致性\|一致性]] 问题，因为一旦网络分区导致参与者无法接受到来自协调者的信息，无论是[[Logseq元知识库/pages/3PC\|3PC]] 中参与者按第一阶段统一意见默认操作(一阶段提交二阶段却abort但有个参与者网络隔断了)，还是[[Logseq元知识库/pages/2PC\|2PC]] 的直接阻塞
					* ![t](https://pic4.zhimg.com/v2-7a18adc27a2bd7b5f5926dd999bc7bb3_r.jpg)
		* [[Logseq元知识库/pages/XA协议.3PC\|XA协议.3PC]] 
			- 其[[Logseq元知识库/pages/3PC\|3PC]] 的流程分为三个阶段：CanCommit、PreCommit和DoCommit。
				- CanCommit阶段：协调者向参与者发送CanCommit请求，询问是否可以执行事务提交操作，并等待参与者的响应。参与者如果可以提交就返回Yes响应，否则返回No响应。
				- PreCommit阶段：如果所有参与者都返回Yes响应，协调者向参与者发送PreCommit请求，并进入Prepared状态。参与者接收到PreCommit请求后，执行事务操作，并将undo和redo信息记录到事务日志中，然后返回ACK响应。如果有任何一个参与者返回No响应或超时，协调者向所有参与者发送abort请求，中断事务。
				- DoCommit阶段：如果协调者收到所有参与者的ACK响应，它将进入提交状态，并向所有参与者发送doCommit请求。参与者接收到doCommit请求后，执行正式的事务提交，并释放事务资源，然后返回ACK响应。如果协调者没有收到所有参与者的ACK响应或超时，它将向所有参与者发送abort请求。参与者接收到abort请求后，利用undo信息回滚事务，并释放事务资源，然后返回ACK响应。
	* [[卡片/P220.简述TCC事务模型\|P220.简述TCC事务模型]]
		* [P220.简述TCC事务模型.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP220.简述TCC事务模型.mp4)
	* [[卡片/P221.如何理解RPC\|P221.如何理解RPC]]
		* [P221.如何理解RPC.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP221.如何理解RPC.mp4)
	* [[卡片/P222.zk的初始化选举和崩溃选举过程\|P222.zk的初始化选举和崩溃选举过程]]
		* [P222.zk的初始化选举和崩溃选举过程.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP222.zk的初始化选举和崩溃选举过程.mp4)
	* [[卡片/P223.简述zk的数据模型\|P223.简述zk的数据模型]]
		* [P223.简述zk的数据模型.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP223.简述zk的数据模型.mp4)
	* [[卡片/P224.zk的数据同步原理\|P224.zk的数据同步原理]]
		* [P224.zk的数据同步原理.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP224.zk的数据同步原理.mp4)
	* [[卡片/P225.zk的watch机制实现原理\|P225.zk的watch机制实现原理]]
		* [P225.zk的watch机制实现原理.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP225.zk的watch机制实现原理.mp4)
	* [[卡片/P226.zk分布式锁实现原理\|P226.zk分布式锁实现原理]]
		* [P226.zk分布式锁实现原理.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP226.zk分布式锁实现原理.mp4)
	* [[卡片/P227.简述zk的典型应用场景\|P227.简述zk的典型应用场景]]
		* [P227.简述zk的典型应用场景.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP227.简述zk的典型应用场景.mp4)
	* [[卡片/P228.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗\|P228.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗]]
		* [P228.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP228.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗.mp4)
	* [[卡片/P229.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗\|P229.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗]]
		* [P229.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP229.zk中一个客户端修改了某个节点的数据，其他客户端能够马上获取到这个最新数据吗.mp4)
	* [[卡片/P230.请谈谈ZK对事务性的支持\|P230.请谈谈ZK对事务性的支持]]
		* [P230.请谈谈ZK对事务性的支持.mp4](file:///C:%5CUsers%5Cliyong%5CDocuments%5CBaiduNetdiskWorkspace%5C哔哩哔哩-Java面试300题（涵盖Java所有知识点）一站式刷题，立刻学习！--诸葛老师%5CP230.请谈谈ZK对事务性的支持.mp4)
			

## ✏想

## ✏识